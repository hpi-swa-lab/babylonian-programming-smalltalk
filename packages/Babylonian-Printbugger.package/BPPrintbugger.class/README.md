When using a traditional debugger, programmers only see object states at fixed points of time in which they placed break points. The feedback loop when searching faults in the code often leads to 'printf' debugging in which programmers add console log statements to print specific, filtered state. As a result, they get a timeline of states instead of just a point of time, which might speed up discovery of the fault. In Babylonian, Probes get close to that behavior of printing every state at once. However, multiple probes are independent from each other and disregard any state which changed between each of their traced values. For example, if users probe the creation of a tree in method A, they might see an empty morph, a morph with a tree stump, and finally a morph with a leaf-filled tree. Other probes in methods B and C might display the addition of every new branch/leaf. As the probes are in no relation, probe A is unable to display the interstates of its morph, forcing users to manually track the control flow and match trace values through different probes. If users decided to print the morph instead of trace it, they could see the whole transformation at once.

With BPPrintbugger, all traced values of probes are put into a chronological context to mimic the printf debugging behavior. Each example gets represented in a BPPrintbuggerColumnMorph as a BPSwimlane which displays the traced value morphs sorted ascending from top to bottom in BPSwimlaneLineMorphs. Examples can be added, switched, de/-activated, modified, and deleted from within the BPPrintbugger. Users might add as many examples in the BPPrintbugger and add as many probes throughout their code as they like with the warning that complex programs in regards to size or many traced values will cause slow performance. Therefore, we advise the usage of this tool for small projects only to keep a lively experience.

The class can be opened by calling 'BPPrintbugger open' or by chosing `BPPrintbugger` for a BPBrowser's side pane.

The BPPrintbugger was created in the context of the "Live Programming" seminar 2021 and enhanced with bidirectional functionality in the context of "Programming Experience" seminar 2022.