When using a traditional debugger, programmers only see object states at fixed points of time in which they placed break points. The feedback loop when searching faults in the code often lead to 'printf' debugging in which programmers add console output to print specific, filtered state. In a result, they get a timeline of state instead of just a point of time which might speed up the fault's discovery. In Babylonian, Probes get close to that behavior of printing every state at once. However, multiple probes are independent from each other and disregard any state which changed between each of their traced values. For example, if users probe the creation of a tree in method A, they might see an empty morph, a morph with a tree stump and finally a morph with a leaf-filled tree. Other probes in methods B and C might display the addition of every new branch/leaf. As the probes are in no relation, probe A is unable to display the interstates of its morph, forcing users to manually track the control flow and match trace values through different probes. If users decided to print the morph instead of trace it, they could see the whole transformation at once.

With BPPrintbugger, all traced values of probes are put into a chronological context to mimic the printf debugging behavior. Each example gets represented as a BPSwimlane which displays the traced value morphs sorted ascending from top to bottom. Active examples are tracked automatically by observing all examples watched by #BPExamples. Users might activate as many examples and add as many probes throughout their code as they like with the warning that complex programs in regards to size or many traced values will cause slow performance. Therefore we advise the usage for small projects only to keep a lively experience.

The class can be opened by calling 'BPPrintbugger open'.

The BPPrintbugger was created in the context of the "Live Programming" seminar 2021.